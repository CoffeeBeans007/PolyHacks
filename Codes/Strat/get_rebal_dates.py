import pandas as pd
from typing import List, Union
from os_helper import OsHelper


class GetRebalDates:
    def __init__(self, termination_date: str, initial_year: int, reb_month: int,
                 reb_week: int, reb_weekday: int, reb_frequency: str):
        """
        Initializes the class to calculate rebalancing dates.

        Args:
            termination_date (str): The date of termination.
            initial_year (int): The initial year of rebalancing.
            reb_month (int): The month for rebalancing.
            reb_week (int): The week number for rebalancing.
            reb_weekday (int): The weekday for rebalancing.
            reb_frequency (str): The frequency of rebalancing.
        """
        self.termination_date = pd.Timestamp(termination_date)
        self.initial_year = initial_year
        self.reb_month = reb_month
        self.reb_week = reb_week
        self.reb_weekday = self._weekday_conversion(weekday=reb_weekday)
        self.reb_frequency = reb_frequency
        self.start_reb_date = self._determine_start_date()
        self.reb_dates = self._generate_reb_dates()

    def _weekday_conversion(self, weekday: Union[int, str]) -> int:
        """
        Converts a string representation of a weekday to its corresponding integer.

        Args:
            weekday (Union[int, str]): The input weekday, either as a string or an integer.

        Returns:
            int: The integer corresponding to the input weekday.
        """
        if isinstance(weekday, str):
            return {'MON': 0, 'TUE': 1, 'WED': 2, 'THU': 3, 'FRI': 4, 'SAT': 5, 'SUN': 6}[weekday.upper()]
        return weekday

    def _determine_start_date(self) -> pd.Timestamp:
        """
        Determines the initial rebalancing date.

        Returns:
            pd.Timestamp: The initial rebalancing date.
        """
        start_of_month = pd.Timestamp(year=self.initial_year, month=self.reb_month, day=1)
        first_occurrence = start_of_month + pd.Timedelta(days=(self.reb_weekday - start_of_month.weekday() + (self.reb_week - 1) * 7))
        return first_occurrence

    def _generate_reb_dates(self) -> List[pd.Timestamp]:
        """
        Generates a list of rebalancing dates based on the specified frequency.

        Returns:
            List[pd.Timestamp]: List of rebalancing dates.
        """
        # Dictionary to map frequency to number of months
        frequency_dict = {'M': 1, 'Q': 3, 'S': 6, 'A': 12}
        reb_dates = [self.start_reb_date]
        subsequent_date = self.start_reb_date

        while True:
            # Add the number of months corresponding to the frequency
            months_to_add = frequency_dict[self.reb_frequency]
            # Add the number of months to the subsequent date
            subsequent_date = subsequent_date + pd.DateOffset(months=months_to_add)
            # Determine the first day of the next month
            first_day_of_next_month = pd.Timestamp(year=subsequent_date.year, month=subsequent_date.month, day=1)
            # Determine the number of days to add to the first day of the next month
            delta_days = (self.reb_weekday - first_day_of_next_month.weekday() + (self.reb_week - 1) * 7)
            # Determine the rebalancing date
            subsequent_date = first_day_of_next_month + pd.Timedelta(days=delta_days)

            # Break if the subsequent date is after the termination date
            if subsequent_date > self.termination_date:
                break

            reb_dates.append(subsequent_date)

        return reb_dates


def filter_by_rebalance_dates(get_reb_dates: GetRebalDates, data: pd.DataFrame) -> pd.DataFrame:
    """
    Filters a DataFrame by the rebalancing dates generated by GetRebalDates.

    Args:
        get_reb_dates (GetRebalDates): An instance of GetRebalDates containing the rebalancing dates.
        data (pd.DataFrame): The input data to filter.

    Returns:
        pd.DataFrame: Data filtered by rebalancing dates.

    Raises:
        ValueError: If the DataFrame columns are not a MultiIndex or the index is not a datetime.
    """
    if not isinstance(data.columns, pd.MultiIndex):
        raise ValueError("Expected a MultiIndex DataFrame.")

    if not isinstance(data.index, pd.DatetimeIndex):
        try:
            data.index = pd.to_datetime(data.index)
            data.index.name = None
        except ValueError:
            raise ValueError("Unable to convert index to datetime.")

    # Transform the DataFrame for filtering
    data_transformed = data.stack(level=0).reset_index()
    data_transformed.columns = ['Date', 'Ticker'] + list(data_transformed.columns[2:])

    # Filter data by rebalancing dates
    filtered_data = data_transformed[data_transformed['Date'].isin(get_reb_dates.reb_dates)]
    filtered_data.reset_index(drop=True, inplace=True)

    return filtered_data


if __name__ == "__main__":
    os_helper = OsHelper()
    all_metrics = os_helper.read_data(directory_name="transform data", file_name="all_metrics.csv", index_col=0, header=[0, 1])
    print(all_metrics.head())

    get_reb_dates = GetRebalDates(
        termination_date='2015-12-31',
        initial_year=2000,
        reb_month=1,
        reb_week=2,
        reb_weekday='FRI',
        reb_frequency='M'
    )
    # Récupération et affichage des dates de rebalancement
    rebalance_dates = get_reb_dates.reb_dates

    print("Dates de rebalancement :")
    for date in rebalance_dates:
        print(date)

    reb_metrics = filter_by_rebalance_dates(get_reb_dates=get_reb_dates, data=all_metrics)
    print(reb_metrics.head())

    # os_helper.write_data(directory_name="transform filtered_data", file_name="rebalance_metrics.csv", data_frame=reb_metrics)

